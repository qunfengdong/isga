# -*- cperl -*-

use File::Copy;

#------------------------------------------------------------------------

=item public void archive();

Create an archive for the FileCollection.

=cut 
#------------------------------------------------------------------------
  sub archive {

    my $self = shift;

    $self->getArchived and X::FileCollection::ArchivedUnsupported->throw( 
      message => 'archive() not supported by archived FileCollections' );

    # create temp file
    my $tar =  $self->getPath;
    open my $fh, '<', $tar or X->throw( message => "unable to open $tar : $!" );
    
    # create file
    my $archive = ISGA::File->addToRepository( $fh, 
					       UserName => 'blargh',
					       Type => ISGA::FileType->new( Name => 'Archived File Collection'),
					       Format => ISGA::FileFormat->new( Name => 'Compressed Tar Archive'),
					       Description => ''
					     );
    
    # save as archive
    $self->edit( Archive => $archive );

    # unlink the archive
    unlink($tar);

  }

#------------------------------------------------------------------------

=item public void inflate();

Inflate an archived FileCollection, creating distinct objects and
files for each of its contents.

=cut 
#------------------------------------------------------------------------
  sub inflate {

    my $self = shift;

    # if any contents exist for this collection, die
    ISGA::FileCollectionContent->exists(FileCollection => $self) 
	and X->throw( message => 'Can not inflate a FileCollection with existing contents' );

    # 
  }

#------------------------------------------------------------------------

=item public void archive();

Create an archive for the FileCollection.

=cut 
#------------------------------------------------------------------------

#------------------------------------------------------------------------

=item public filehandle addToTar( Archive::Tar $archive, string $prefix );

Adds the contents of the current file collection the the passed tar
archive reference. This nests a file collection inside another one.

=cut 
#------------------------------------------------------------------------
  sub addToTar {

    my ($self, $archive, $prefix) = @_;

    my $contents = $self->getContents;

    $prefix .= '/' . $self->getUserName;

    foreach ( @$contents ) {

      if ( $_->isa('ISGA::File') ) {
        my $logical_path = $prefix . "/" . $_->getUserName;
        my ( $file ) = $archive->add( $logical_path, $_->getPath );

      # process nested collections
      } else {
	$_->addToTar( $archive, $prefix );
      }
    }

  }

#------------------------------------------------------------------------

=item public void delete();

Removes a file collection from the database. Any files or collections
that do not exist outisde of the collection will also be deleted.

=cut 
#------------------------------------------------------------------------
  sub delete {

    my $self = shift;

    $self->deleteContents();
    $self->deleteArchive();

    # delete the database entry
    $self->NEXT::delete();
  }

#------------------------------------------------------------------------

=item public void deleteArchive();

Removes the archive of a FileCollection. If the collection hasn't
first been expanded, the data will be permanently lost.

=cut 
#------------------------------------------------------------------------
  sub deleteArchive {

    my $self = shift;

    my $archive = $self->getArchive() or return;

    $self->edit( Archive => undef );
    $archive->delete();
  }

#------------------------------------------------------------------------

=item public void deleteContents();

Removes a file collections contents from the system.

=cut 
#------------------------------------------------------------------------
  sub deleteContents {

    my $self = shift;

    # delete all the contents
    my $contents = ISGA::FileCollectionContent->query( FileCollection => $self,
						       OrderBy => 'Index' );
    $_->delete for reverse @$contents;
  }

#------------------------------------------------------------------------

=item public void stage(string $dir);

Stages this file for an ergatis run.

=cut 
#------------------------------------------------------------------------
  sub stage {

    my ($self, $dir) = @_;

    $self->getArchived and X::FileCollection::ArchivedUnsupported->throw( 
       message => 'stage() not supported by archived FileCollections' );

    my $name = $self->getName;

    # open file for writing
    open my $fh, '>', "$dir/$name" or X::File->throw( error => $! );

    foreach ( @{$self->getFlattenedContents} ) {

      # write the file to the file system
      $_->stage($dir);

      print $fh $dir, "/", $_->getName, "\n";
    }
    
    close $fh;
  }
