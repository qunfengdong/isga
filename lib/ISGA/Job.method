# -*- cperl -*-

use File::Basename;
use YAML;
use IO::String;
use List::MoreUtils qw(any);


#------------------------------------------------------------------------

=item public Job new()

We override the base constructor to promote our class to what is
defined by the JobType for this object.

=cut
#------------------------------------------------------------------------
sub new {

  my $class = shift;

  # build the object as normal
  my $self = $class->NEXT::new(@_);

  bless($self, $self->getType->getClass);

  return $self;
}

#------------------------------------------------------------------------

=item public Job query()

We override the base constructor to promote our class to what is
defined by the JobType for this object.

=cut
#------------------------------------------------------------------------
sub query {

  my $class = shift;

  # build the object as normal
  my $selves = $class->NEXT::query(@_);

  # do the new trick on all the found jobs
  return [map { bless($_, $_->getType->getClass) } @$selves];
}

my @terminal_statuses = qw(Finished Error Failed);

#------------------------------------------------------------------------

=item public void updateStatus();

Updates the job status by running qstat on sge. This will
update the job status.

=cut
#------------------------------------------------------------------------
sub updateStatus {

  my $self = shift;

  my $old_status = $self->getStatus;
  return if any { $_ eq $old_status } @terminal_statuses;

  my $env = $self->getEnvironment();

  eval {

    ISGA::DB->begin_work();

    # call out to the environment to check the status
    my $new_status = $env->checkJobStatus( $self );
    
    # update the status if it has changed
    $self->edit( Status => $new_status ) unless $new_status eq $old_status;

    if ( $new_status eq 'Finished' ){
        my $collection = $self->getCollection;
        my $contents = $collection->getContents;
        my $list;
        foreach (@$contents){
                if ($_->getType->getName eq 'Toolbox Job Configuration'){
                        use YAML;
                        $list = YAML::LoadFile($_->getPath);
                }
        }
        
        my $output_file = $list->{'output_file'};
        if (-e $output_file) {
          my $type = $list->{'output_type'};
          my $format = $list->{'output_format'};
          if (defined $type){
            $self->addOutputToCollection($output_file, $type, $format);
          }else{
            $self->addOutputToCollection($output_file);
          }
        } else {
          $new_status = 'Error';
          $self->edit( Status => $new_status );
        }

        if (-e "$output_file.xls") {
          my $html = "$output_file.xls";
          $self->addHTMLOutputToCollection($html);
        }
        if (-e "$output_file.txt") {
          my $html = "$output_file.txt";
          $self->addHTMLOutputToCollection($html);
        }
    }

    if ( any { $new_status eq $_ } @terminal_statuses ) {
      $self->edit( FinishedAt => ISGA::Timestamp->new() );
    }

    ISGA::DB->commit();
  };

  if ( $@ ) {
    ISGA::DB->rollback();

    my $e = ( X->caught() ? $@ : X::Dropped->new(error => $@) );    
    $e->rethrow();
  }  
 
}

#------------------------------------------------------------------------

=item public File buildQueryFile( File => $file, Upload => $fh, String => $string);

The methods takes the job input (either as a previously existing ISGA
file, an uploaded file, or input to a form element) and creates an
input file for the job. The input is saved in the ISGA file repository
if it doesn't already exist.

=cut
#------------------------------------------------------------------------
sub buildQueryFile {

  my ($class, %args) = @_;

  # both of these are undefined to start with, lines may set them to circumvent unecessary work
  my $input_file = undef;
  my $fh = undef;

  # we no longer allow users to mix a stored file with text input or upload

  # do we have a file
  if ( exists $args{File} ) {
    $input_file = $args{File};

  # do we have a filehandle
  } elsif ( exists $args{Upload} ) {
    $fh = $args{Upload};

  # do we have a string
  } elsif ( exists $args{String} ) {
    open $fh, '<', \$args{String};

  # otherwise we forgot input
  } else { X::API->throw( error => 'No input was supplied for workbench Job' ); }

  # if we have a filehandle, lets create an object out of it
  if ( $fh ) {

    # if we're given a FASTA file, we do some filtering
    $fh = ISGA::FileFormat::FASTA->format($fh) if($args{Format} eq 'FASTA');

    $input_file = ISGA::File->upload($fh,
                                         UserName => $args{Username},
                                         Type => ISGA::FileType->new( Name => $args{Type} ),
                                         Format => ISGA::FileFormat->new( Name => $args{Format} ),
                                         Description => $args{Description},
                                         CreatedBy => ISGA::Login->getAccount,
                                         CreatedAt => ISGA::Timestamp->new(),
                                         IsHidden => 0,
                                         ExistsOutsideCollection => 0
                                        );
  }

  $class->addInputToCollection($input_file);

  # save the file into the YAML config for this job
  return $input_file;
}

#------------------------------------------------------------------------

=item public void buildConfigFile( String => $string);

This method creates the ConfigFile for a BLAST job in yaml format.
The file contains information about the job id, the query databases,
the blast parameters, and the input file.

=cut
#------------------------------------------------------------------------
sub buildConfigFile{
  my ($self, $config_args) = @_;

  my $tmp = '___tmp_file_directory___' . time . $$ . $self->getType->getName . 'Config.yaml';

  my %args = ( Type => ISGA::FileType->new( Name => 'Toolbox Job Configuration'),
               Format => ISGA::FileFormat->new( Name => 'YAML' ),
               IsHidden => 1, UserName => basename($tmp),
               CreatedAt => ISGA::Timestamp->new(),
               CreatedBy => ISGA::Login->getAccount,
               ExistsOutsideCollection => 0, Description => 'Config for ' . $self->getType->getName );


  my $fh = File::Temp->new;
  print $fh YAML::Dump($config_args);
  seek($fh,0,0);

  my $file = ISGA::File->addToRepository( $fh, %args );

  my $next_index = ISGA::FileCollectionContent->exists( FileCollection => $self->getCollection );

  ISGA::FileCollectionContent->create( FileCollection => $self->getCollection,
				       FileResource => $file,
				       Index => $next_index++
				     );

}

#------------------------------------------------------------------------

=item public void addInputToCollection( String => $string);

This method adds the input file to the collection. 

=cut
#------------------------------------------------------------------------
sub addInputToCollection {
  my ($self, $input) = @_;

  my $next_index = ISGA::FileCollectionContent->exists( FileCollection => $self->getCollection );

  ISGA::FileCollectionContent->create( FileCollection => $self->getCollection,
                                           FileResource => $input,
                                           Index => $next_index++
                                         );

}

#------------------------------------------------------------------------

=item public void addOuputToCollection( String => $string);

This method adds the output file to the collection. 

=cut
#------------------------------------------------------------------------
sub addOutputToCollection {
  my ($self, $output) = @_;

  open my $fh, '<', $output or X::File->throw( error => "Cant open $output - $!" );

  seek($fh,0,0);

  my $output_file = 
    ISGA::File->addToRepository( $fh,
				 UserName => basename($output),
				 Type => ISGA::FileType->new( Name => $self->getOutputType ),
				 Format => ISGA::FileFormat->new( Name =>  $self->getOutputFormat ),
				 Description => 'Output file for '.$self->getType->getName.' job',
				 CreatedBy => ISGA::Login->getAccount,
				 CreatedAt => ISGA::Timestamp->new(),
				 IsHidden => 0,
				 ExistsOutsideCollection => 0
			       );
  my $next_index = ISGA::FileCollectionContent->exists( FileCollection => $self->getCollection );

  ISGA::FileCollectionContent->create( FileCollection => $self->getCollection,
                                       FileResource => $output_file,
                                       Index => $next_index++
                                     );
#  return $output_file;

}


#------------------------------------------------------------------------

=item public void addHTMLOuputToCollection( String => $string);

This method adds the preprocessed HTML output file to the collection. 

=cut
#------------------------------------------------------------------------
sub addHTMLOutputToCollection {
  my ($self, $output) = @_;

  open my $fh, '<', $output or X::File->throw( error => "Cant open $output - $!" );

  seek($fh,0,0);
  my $output_file = 
    ISGA::File->addToRepository( $fh,
				 UserName => basename($output),
				 Type => ISGA::FileType->new( Name => 'BLAST HTML Result'),
				 Format => ISGA::FileFormat->new( Name => 'BLAST Raw Results' ),
				 Description => 'Output file for BLAST job',
				 CreatedBy => ISGA::Login->getAccount,
				 CreatedAt => ISGA::Timestamp->new(),
				 IsHidden => 0,
				 ExistsOutsideCollection => 0
			       );
  my $next_index = ISGA::FileCollectionContent->exists( FileCollection => $self->getCollection );

  ISGA::FileCollectionContent->create( FileCollection => $self->getCollection,
                                       FileResource => $output_file,
                                       Index => $next_index++
                                     );
}

#------------------------------------------------------------------------

=item public void addXLSOuputToCollection( String => $string);

This method adds the preprocessed HTML output file to the collection. 

=cut
#------------------------------------------------------------------------
sub addXLSOutputToCollection {
  my ($self, $output) = @_;

  open my $fh, '<', $output or X::File->throw( error => "Cant open $output - $!" );

  seek($fh,0,0);
  my $output_file = 
    ISGA::File->addToRepository( $fh,
				 UserName => basename($output),
				 Type => ISGA::FileType->new( Name => 'BLAST HTML Result'),
				 Format => ISGA::FileFormat->new( Name => 'BLAST Raw Results' ),
				 Description => 'Output file for BLAST job',
				 CreatedBy => ISGA::Login->getAccount,
				 CreatedAt => ISGA::Timestamp->new(),
				 IsHidden => 0,
				 ExistsOutsideCollection => 0
			       );
  my $next_index = ISGA::FileCollectionContent->exists( FileCollection => $self->getCollection );

  ISGA::FileCollectionContent->create( FileCollection => $self->getCollection,
                                       FileResource => $output_file,
                                       Index => $next_index++
                                     );
}

